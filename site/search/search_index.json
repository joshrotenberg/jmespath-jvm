{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jmespath-jvm","text":"<p>A fast, spec-compliant JMESPath implementation for the JVM with zero dependencies.</p>"},{"location":"#why-jmespath-jvm","title":"Why jmespath-jvm?","text":"<ul> <li>Fast - 4-10x faster parsing, 30-70% faster evaluation than alternatives</li> <li>Complete - Full JMESPath spec plus JEP-12 (raw strings) and JEP-18 (lexical scoping)</li> <li>Zero dependencies - Just the JDK, nothing else</li> <li>Extensible - Add custom functions easily</li> <li>Any JSON library - Jackson, Gson, or plain Maps - your choice</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import io.jmespath.JmesPath;\n\n// Given this JSON data:\n// {\n//   \"people\": [\n//     {\"name\": \"Alice\", \"age\": 25},\n//     {\"name\": \"Bob\", \"age\": 30},\n//     {\"name\": \"Charlie\", \"age\": 35}\n//   ]\n// }\n\n// Find names of people over 28\nObject result = JmesPath.search(\"people[?age &gt; `28`].name\", data);\n// Returns: [\"Bob\", \"Charlie\"]\n</code></pre>"},{"location":"#installation","title":"Installation","text":"MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.jmespath&lt;/groupId&gt;\n    &lt;artifactId&gt;jmespath-jvm&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.jmespath:jmespath-jvm:0.1.0'\n</code></pre>"},{"location":"#what-is-jmespath","title":"What is JMESPath?","text":"<p>JMESPath is a query language for JSON. It lets you extract, transform, and filter data from JSON documents using a simple, declarative syntax.</p> <pre><code>people[?age &gt; `21`].name | sort(@) | [0]\n</code></pre> <p>This expression:</p> <ol> <li>Filters <code>people</code> to those with <code>age &gt; 21</code></li> <li>Extracts just the <code>name</code> field from each</li> <li>Sorts the names</li> <li>Returns the first one</li> </ol> <p>Learn more at jmespath.org.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and first queries</li> <li>User Guide - Learn the query language</li> <li>API Reference - Javadoc documentation</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add jmespath-jvm to your project:</p> MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.jmespath&lt;/groupId&gt;\n    &lt;artifactId&gt;jmespath-jvm&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.jmespath:jmespath-jvm:0.1.0'\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#one-liner-queries","title":"One-liner Queries","text":"<p>The simplest way to use jmespath-jvm:</p> <pre><code>import io.jmespath.JmesPath;\nimport java.util.*;\n\n// Create some data\nMap&lt;String, Object&gt; data = new HashMap&lt;&gt;();\ndata.put(\"name\", \"Alice\");\ndata.put(\"age\", 30);\n\n// Query it\nString name = (String) JmesPath.search(\"name\", data);  // \"Alice\"\n</code></pre>"},{"location":"getting-started/#compiled-expressions","title":"Compiled Expressions","text":"<p>For repeated queries, compile once and reuse:</p> <pre><code>import io.jmespath.JmesPath;\nimport io.jmespath.Expression;\n\n// Compile the expression\nExpression&lt;Object&gt; expr = JmesPath.compile(\"people[?active].name\");\n\n// Use it many times\nObject result1 = expr.search(dataset1);\nObject result2 = expr.search(dataset2);\nObject result3 = expr.search(dataset3);\n</code></pre> <p>Compiled expressions are:</p> <ul> <li>Immutable - safe to share across threads</li> <li>Reusable - no parsing overhead on each call</li> <li>Fast - optimized AST ready to evaluate</li> </ul>"},{"location":"getting-started/#working-with-arrays","title":"Working with Arrays","text":"<pre><code>// Sample data\n// {\n//   \"people\": [\n//     {\"name\": \"Alice\", \"age\": 25},\n//     {\"name\": \"Bob\", \"age\": 30}\n//   ]\n// }\n\n// Get all names\nList&lt;?&gt; names = (List&lt;?&gt;) JmesPath.search(\"people[*].name\", data);\n// [\"Alice\", \"Bob\"]\n\n// Get first person's name\nString first = (String) JmesPath.search(\"people[0].name\", data);\n// \"Alice\"\n\n// Get last person\nMap&lt;?,?&gt; last = (Map&lt;?,?&gt;) JmesPath.search(\"people[-1]\", data);\n// {\"name\": \"Bob\", \"age\": 30}\n</code></pre>"},{"location":"getting-started/#filtering","title":"Filtering","text":"<pre><code>// People over 25\nJmesPath.search(\"people[?age &gt; `25`]\", data);\n\n// People named Alice\nJmesPath.search(\"people[?name == 'Alice']\", data);\n\n// Combine conditions\nJmesPath.search(\"people[?age &gt; `20` &amp;&amp; age &lt; `30`]\", data);\n</code></pre> <p>Literals</p> <p>Use backticks for JSON literals (<code>`25`</code>) and single quotes for raw strings (<code>'Alice'</code>).</p>"},{"location":"getting-started/#using-functions","title":"Using Functions","text":"<pre><code>// Count items\nJmesPath.search(\"length(people)\", data);  // 2\n\n// Sort by age\nJmesPath.search(\"sort_by(people, &amp;age)\", data);\n\n// Get the oldest person's name\nJmesPath.search(\"max_by(people, &amp;age).name\", data);\n\n// Join names with comma\nJmesPath.search(\"join(', ', people[*].name)\", data);  // \"Alice, Bob\"\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<pre><code>import io.jmespath.JmesPathException;\n\ntry {\n    JmesPath.compile(\"invalid[expression\");\n} catch (JmesPathException e) {\n    System.out.println(\"Error: \" + e.getMessage());\n    System.out.println(\"Position: \" + e.getPosition());\n    System.out.println(\"Line: \" + e.getLine());\n    System.out.println(\"Column: \" + e.getColumn());\n}\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Queries - Property access, indexes, slicing</li> <li>Filters - Filter expressions in depth</li> <li>Functions - All 26 built-in functions</li> </ul>"},{"location":"advanced/custom-functions/","title":"Custom Functions","text":"<p>Extend jmespath-jvm with your own functions.</p>"},{"location":"advanced/custom-functions/#quick-start","title":"Quick Start","text":"<pre><code>import io.jmespath.function.*;\nimport io.jmespath.runtime.MapRuntime;\nimport io.jmespath.JmesPath;\n\n// Create a custom function\nFunction doubleIt = FunctionBuilder.function(\"double\")\n    .arg(ArgumentType.NUMBER)\n    .body((runtime, args, current) -&gt; {\n        Number n = (Number) args.get(0);\n        return runtime.createNumber(n.doubleValue() * 2);\n    })\n    .build();\n\n// Register it\nFunctionRegistry registry = DefaultFunctionRegistry.withExtension(doubleIt);\nMapRuntime runtime = new MapRuntime(registry);\n\n// Use it\nExpression&lt;Object&gt; expr = JmesPath.compile(\"double(price)\");\nObject result = expr.evaluate(runtime, data);  // price * 2\n</code></pre>"},{"location":"advanced/custom-functions/#function-builder-api","title":"Function Builder API","text":""},{"location":"advanced/custom-functions/#argument-types","title":"Argument Types","text":"Type Accepts <code>ANY</code> Any value <code>STRING</code> String values <code>NUMBER</code> Numeric values <code>BOOLEAN</code> Boolean values <code>ARRAY</code> Array values <code>OBJECT</code> Object values <code>EXPRESSION</code> Expression reference (<code>&amp;expr</code>) <code>ARRAY_STRING</code> Array of strings <code>ARRAY_NUMBER</code> Array of numbers"},{"location":"advanced/custom-functions/#required-arguments","title":"Required Arguments","text":"<pre><code>FunctionBuilder.function(\"add\")\n    .arg(ArgumentType.NUMBER)\n    .arg(ArgumentType.NUMBER)\n    .body((runtime, args, current) -&gt; {\n        double a = ((Number) args.get(0)).doubleValue();\n        double b = ((Number) args.get(1)).doubleValue();\n        return runtime.createNumber(a + b);\n    })\n    .build();\n</code></pre>"},{"location":"advanced/custom-functions/#optional-arguments","title":"Optional Arguments","text":"<pre><code>FunctionBuilder.function(\"pad\")\n    .arg(ArgumentType.STRING)\n    .arg(ArgumentType.NUMBER)\n    .optionalArg(ArgumentType.STRING)  // optional padding char\n    .body((runtime, args, current) -&gt; {\n        String s = (String) args.get(0);\n        int width = ((Number) args.get(1)).intValue();\n        String pad = args.size() &gt; 2 ? (String) args.get(2) : \" \";\n        // ... padding logic\n        return runtime.createString(result);\n    })\n    .build();\n</code></pre>"},{"location":"advanced/custom-functions/#variadic-arguments","title":"Variadic Arguments","text":"<pre><code>FunctionBuilder.function(\"concat\")\n    .varargs(ArgumentType.STRING)\n    .body((runtime, args, current) -&gt; {\n        StringBuilder sb = new StringBuilder();\n        for (Object arg : args) {\n            sb.append((String) arg);\n        }\n        return runtime.createString(sb.toString());\n    })\n    .build();\n</code></pre>"},{"location":"advanced/custom-functions/#expression-arguments","title":"Expression Arguments","text":"<p>For functions like <code>sort_by</code> that take expression references:</p> <pre><code>FunctionBuilder.function(\"count_by\")\n    .arg(ArgumentType.ARRAY)\n    .arg(ArgumentType.EXPRESSION)\n    .body((runtime, args, current) -&gt; {\n        List&lt;?&gt; array = (List&lt;?&gt;) args.get(0);\n        ExpressionRefNode expr = (ExpressionRefNode) args.get(1);\n\n        Map&lt;Object, Integer&gt; counts = new HashMap&lt;&gt;();\n        for (Object item : array) {\n            Object key = expr.evaluate(runtime, item);\n            counts.merge(key, 1, Integer::sum);\n        }\n\n        return runtime.createObject(counts);\n    })\n    .build();\n</code></pre>"},{"location":"advanced/custom-functions/#implementing-function-interface","title":"Implementing Function Interface","text":"<p>For more control, implement <code>Function</code> directly:</p> <pre><code>public class UpperFunction implements Function {\n\n    @Override\n    public String getName() {\n        return \"upper\";\n    }\n\n    @Override\n    public Signature getSignature() {\n        return new Signature(\n            new Argument(ArgumentType.STRING)\n        );\n    }\n\n    @Override\n    public &lt;T&gt; T call(Runtime&lt;T&gt; runtime, List&lt;Object&gt; args, T current) {\n        String s = (String) args.get(0);\n        return runtime.createString(s.toUpperCase());\n    }\n}\n</code></pre>"},{"location":"advanced/custom-functions/#registering-functions","title":"Registering Functions","text":""},{"location":"advanced/custom-functions/#single-function","title":"Single Function","text":"<pre><code>FunctionRegistry registry = DefaultFunctionRegistry.withExtension(myFunction);\n</code></pre>"},{"location":"advanced/custom-functions/#multiple-functions","title":"Multiple Functions","text":"<pre><code>FunctionRegistry registry = DefaultFunctionRegistry.withExtensions(\n    func1, func2, func3\n);\n</code></pre>"},{"location":"advanced/custom-functions/#custom-registry","title":"Custom Registry","text":"<pre><code>FunctionRegistry registry = new FunctionRegistry();\nregistry.register(new LengthFunction());\nregistry.register(new SortFunction());\nregistry.register(myCustomFunction);\n// Only these functions are available\n</code></pre>"},{"location":"advanced/custom-functions/#using-custom-runtime","title":"Using Custom Runtime","text":"<pre><code>// Create runtime with custom functions\nMapRuntime runtime = new MapRuntime(registry);\n\n// Compile expression\nExpression&lt;Object&gt; expr = JmesPath.compile(\"upper(name)\");\n\n// Evaluate with custom runtime\nObject result = expr.evaluate(runtime, data);\n</code></pre>"},{"location":"advanced/custom-functions/#example-string-functions","title":"Example: String Functions","text":"<pre><code>Function upper = FunctionBuilder.function(\"upper\")\n    .arg(ArgumentType.STRING)\n    .body((runtime, args, current) -&gt; \n        runtime.createString(((String) args.get(0)).toUpperCase()))\n    .build();\n\nFunction lower = FunctionBuilder.function(\"lower\")\n    .arg(ArgumentType.STRING)\n    .body((runtime, args, current) -&gt; \n        runtime.createString(((String) args.get(0)).toLowerCase()))\n    .build();\n\nFunction trim = FunctionBuilder.function(\"trim\")\n    .arg(ArgumentType.STRING)\n    .body((runtime, args, current) -&gt; \n        runtime.createString(((String) args.get(0)).trim()))\n    .build();\n\nFunctionRegistry registry = DefaultFunctionRegistry.withExtensions(\n    upper, lower, trim\n);\n</code></pre>"},{"location":"advanced/custom-functions/#example-math-functions","title":"Example: Math Functions","text":"<pre><code>Function round = FunctionBuilder.function(\"round\")\n    .arg(ArgumentType.NUMBER)\n    .optionalArg(ArgumentType.NUMBER)\n    .body((runtime, args, current) -&gt; {\n        double n = ((Number) args.get(0)).doubleValue();\n        int places = args.size() &gt; 1 ? ((Number) args.get(1)).intValue() : 0;\n        double factor = Math.pow(10, places);\n        return runtime.createNumber(Math.round(n * factor) / factor);\n    })\n    .build();\n\nFunction sqrt = FunctionBuilder.function(\"sqrt\")\n    .arg(ArgumentType.NUMBER)\n    .body((runtime, args, current) -&gt; {\n        double n = ((Number) args.get(0)).doubleValue();\n        return runtime.createNumber(Math.sqrt(n));\n    })\n    .build();\n</code></pre>"},{"location":"advanced/custom-functions/#error-handling","title":"Error Handling","text":"<p>Throw <code>JmesPathException</code> for runtime errors:</p> <pre><code>FunctionBuilder.function(\"divide\")\n    .arg(ArgumentType.NUMBER)\n    .arg(ArgumentType.NUMBER)\n    .body((runtime, args, current) -&gt; {\n        double a = ((Number) args.get(0)).doubleValue();\n        double b = ((Number) args.get(1)).doubleValue();\n        if (b == 0) {\n            throw new JmesPathException(\"divide: division by zero\");\n        }\n        return runtime.createNumber(a / b);\n    })\n    .build();\n</code></pre>"},{"location":"advanced/custom-runtimes/","title":"Custom Runtimes","text":"<p>Integrate jmespath-jvm with any JSON library by implementing the <code>Runtime</code> interface.</p>"},{"location":"advanced/custom-runtimes/#why-custom-runtimes","title":"Why Custom Runtimes?","text":"<p>The default <code>MapRuntime</code> uses <code>Map&lt;String, Object&gt;</code> and <code>List&lt;Object&gt;</code>. But you might want to:</p> <ul> <li>Use Jackson's <code>JsonNode</code> directly</li> <li>Use Gson's <code>JsonElement</code></li> <li>Work with your own domain objects</li> <li>Optimize for your specific use case</li> </ul>"},{"location":"advanced/custom-runtimes/#the-runtime-interface","title":"The Runtime Interface","text":"<pre><code>public interface Runtime&lt;T&gt; {\n\n    // Type checking\n    boolean isNull(T value);\n    boolean isBoolean(T value);\n    boolean isNumber(T value);\n    boolean isString(T value);\n    boolean isArray(T value);\n    boolean isObject(T value);\n    Type typeOf(T value);\n\n    // Value extraction\n    T getProperty(T object, String name);\n    T getIndex(T array, int index);\n    int getArrayLength(T array);\n    Iterable&lt;T&gt; getArrayElements(T array);\n    Iterable&lt;String&gt; getObjectKeys(T object);\n    Iterable&lt;T&gt; getObjectValues(T object);\n\n    // Conversion to Java types\n    boolean toBoolean(T value);\n    Number toNumber(T value);\n    String toString(T value);\n\n    // Value construction\n    T createNull();\n    T createBoolean(boolean value);\n    T createNumber(Number value);\n    T createString(String value);\n    T createArray(List&lt;T&gt; elements);\n    T createObject(Map&lt;String, T&gt; properties);\n\n    // Comparison\n    int compare(T a, T b);\n    boolean deepEquals(T a, T b);\n    boolean isTruthy(T value);\n\n    // JSON parsing (for literals)\n    T parseJson(String json);\n\n    // Function registry\n    FunctionRegistry getFunctionRegistry();\n}\n</code></pre>"},{"location":"advanced/custom-runtimes/#jackson-example","title":"Jackson Example","text":"<pre><code>public class JacksonRuntime implements Runtime&lt;JsonNode&gt; {\n\n    private final ObjectMapper mapper = new ObjectMapper();\n    private final FunctionRegistry functions;\n\n    public JacksonRuntime() {\n        this.functions = new DefaultFunctionRegistry();\n    }\n\n    public JacksonRuntime(FunctionRegistry functions) {\n        this.functions = functions;\n    }\n\n    // Type checking\n\n    @Override\n    public boolean isNull(JsonNode value) {\n        return value == null || value.isNull();\n    }\n\n    @Override\n    public boolean isBoolean(JsonNode value) {\n        return value != null &amp;&amp; value.isBoolean();\n    }\n\n    @Override\n    public boolean isNumber(JsonNode value) {\n        return value != null &amp;&amp; value.isNumber();\n    }\n\n    @Override\n    public boolean isString(JsonNode value) {\n        return value != null &amp;&amp; value.isTextual();\n    }\n\n    @Override\n    public boolean isArray(JsonNode value) {\n        return value != null &amp;&amp; value.isArray();\n    }\n\n    @Override\n    public boolean isObject(JsonNode value) {\n        return value != null &amp;&amp; value.isObject();\n    }\n\n    @Override\n    public Type typeOf(JsonNode value) {\n        if (value == null || value.isNull()) return Type.NULL;\n        if (value.isBoolean()) return Type.BOOLEAN;\n        if (value.isNumber()) return Type.NUMBER;\n        if (value.isTextual()) return Type.STRING;\n        if (value.isArray()) return Type.ARRAY;\n        if (value.isObject()) return Type.OBJECT;\n        return Type.NULL;\n    }\n\n    // Value extraction\n\n    @Override\n    public JsonNode getProperty(JsonNode object, String name) {\n        if (object == null || !object.isObject()) return null;\n        return object.get(name);\n    }\n\n    @Override\n    public JsonNode getIndex(JsonNode array, int index) {\n        if (array == null || !array.isArray()) return null;\n        if (index &lt; 0 || index &gt;= array.size()) return null;\n        return array.get(index);\n    }\n\n    @Override\n    public int getArrayLength(JsonNode array) {\n        if (array == null || !array.isArray()) return 0;\n        return array.size();\n    }\n\n    @Override\n    public Iterable&lt;JsonNode&gt; getArrayElements(JsonNode array) {\n        if (array == null || !array.isArray()) {\n            return Collections.emptyList();\n        }\n        return array;\n    }\n\n    @Override\n    public Iterable&lt;String&gt; getObjectKeys(JsonNode object) {\n        if (object == null || !object.isObject()) {\n            return Collections.emptyList();\n        }\n        List&lt;String&gt; keys = new ArrayList&lt;&gt;();\n        object.fieldNames().forEachRemaining(keys::add);\n        return keys;\n    }\n\n    @Override\n    public Iterable&lt;JsonNode&gt; getObjectValues(JsonNode object) {\n        if (object == null || !object.isObject()) {\n            return Collections.emptyList();\n        }\n        List&lt;JsonNode&gt; values = new ArrayList&lt;&gt;();\n        object.elements().forEachRemaining(values::add);\n        return values;\n    }\n\n    // Conversion\n\n    @Override\n    public boolean toBoolean(JsonNode value) {\n        return value != null &amp;&amp; value.isBoolean() &amp;&amp; value.booleanValue();\n    }\n\n    @Override\n    public Number toNumber(JsonNode value) {\n        if (value == null || !value.isNumber()) return null;\n        return value.numberValue();\n    }\n\n    @Override\n    public String toString(JsonNode value) {\n        if (value == null) return \"null\";\n        if (value.isTextual()) return value.textValue();\n        return value.toString();\n    }\n\n    // Value construction\n\n    @Override\n    public JsonNode createNull() {\n        return NullNode.getInstance();\n    }\n\n    @Override\n    public JsonNode createBoolean(boolean value) {\n        return BooleanNode.valueOf(value);\n    }\n\n    @Override\n    public JsonNode createNumber(Number value) {\n        if (value instanceof Integer) {\n            return IntNode.valueOf(value.intValue());\n        }\n        if (value instanceof Long) {\n            return LongNode.valueOf(value.longValue());\n        }\n        return DoubleNode.valueOf(value.doubleValue());\n    }\n\n    @Override\n    public JsonNode createString(String value) {\n        return TextNode.valueOf(value);\n    }\n\n    @Override\n    public JsonNode createArray(List&lt;JsonNode&gt; elements) {\n        ArrayNode array = mapper.createArrayNode();\n        array.addAll(elements);\n        return array;\n    }\n\n    @Override\n    public JsonNode createObject(Map&lt;String, JsonNode&gt; properties) {\n        ObjectNode obj = mapper.createObjectNode();\n        obj.setAll(properties);\n        return obj;\n    }\n\n    // Comparison\n\n    @Override\n    public int compare(JsonNode a, JsonNode b) {\n        if (isNumber(a) &amp;&amp; isNumber(b)) {\n            return Double.compare(\n                a.doubleValue(), \n                b.doubleValue()\n            );\n        }\n        if (isString(a) &amp;&amp; isString(b)) {\n            return a.textValue().compareTo(b.textValue());\n        }\n        return 0;\n    }\n\n    @Override\n    public boolean deepEquals(JsonNode a, JsonNode b) {\n        if (a == b) return true;\n        if (a == null || b == null) return false;\n        return a.equals(b);\n    }\n\n    @Override\n    public boolean isTruthy(JsonNode value) {\n        if (value == null || value.isNull()) return false;\n        if (value.isBoolean()) return value.booleanValue();\n        if (value.isTextual()) return !value.textValue().isEmpty();\n        if (value.isArray()) return value.size() &gt; 0;\n        if (value.isObject()) return value.size() &gt; 0;\n        return true;\n    }\n\n    // JSON parsing\n\n    @Override\n    public JsonNode parseJson(String json) {\n        try {\n            return mapper.readTree(json);\n        } catch (Exception e) {\n            throw new JmesPathException(\"Invalid JSON: \" + e.getMessage());\n        }\n    }\n\n    // Functions\n\n    @Override\n    public FunctionRegistry getFunctionRegistry() {\n        return functions;\n    }\n}\n</code></pre>"},{"location":"advanced/custom-runtimes/#using-custom-runtime","title":"Using Custom Runtime","text":"<pre><code>// Create your runtime\nJacksonRuntime runtime = new JacksonRuntime();\n\n// Parse your data\nJsonNode data = runtime.parseJson(\"{\\\"name\\\": \\\"Alice\\\"}\");\n\n// Compile and evaluate\nExpression&lt;JsonNode&gt; expr = JmesPath.compile(\"name\");\nJsonNode result = expr.evaluate(runtime, data);\n\n// Result is a JsonNode\nString name = result.textValue();  // \"Alice\"\n</code></pre>"},{"location":"advanced/custom-runtimes/#thread-safety","title":"Thread Safety","text":"<p>Your runtime should be thread-safe if you plan to share it across threads. The built-in <code>MapRuntime</code> is thread-safe.</p> <p>Key considerations:</p> <ul> <li>Make the runtime stateless if possible</li> <li>Use thread-safe collections if you need state</li> <li>The <code>FunctionRegistry</code> is effectively immutable after setup</li> </ul>"},{"location":"advanced/custom-runtimes/#performance-tips","title":"Performance Tips","text":"<ol> <li>Avoid allocations in hot paths like <code>getProperty</code> and <code>getIndex</code></li> <li>Cache frequently accessed values</li> <li>Use primitive types where possible in comparisons</li> <li>Pre-size collections in <code>createArray</code> and <code>createObject</code></li> </ol>"},{"location":"advanced/lexical-scoping/","title":"Lexical Scoping (JEP-18)","text":"<p>jmespath-jvm implements JEP-18, adding <code>let</code> expressions and variable references to JMESPath.</p>"},{"location":"advanced/lexical-scoping/#the-problem","title":"The Problem","text":"<p>Standard JMESPath has no way to:</p> <ul> <li>Reference the root document from within nested expressions</li> <li>Store intermediate results for reuse</li> <li>Reference parent data from within filter expressions</li> </ul> <p>Consider finding people whose age is above the group's average:</p> <pre><code>{\n  \"people\": [\n    {\"name\": \"Alice\", \"age\": 30},\n    {\"name\": \"Bob\", \"age\": 25},\n    {\"name\": \"Carol\", \"age\": 35}\n  ]\n}\n</code></pre> <p>In standard JMESPath, you can't compare each person's age to <code>avg(people[*].age)</code> because inside the filter, you've lost access to the root.</p>"},{"location":"advanced/lexical-scoping/#let-expressions","title":"Let Expressions","text":"<p>The <code>let</code> keyword binds values to variables:</p> <pre><code>let $avg = avg(people[*].age)\nin people[?age &gt; $avg].name\n</code></pre> <p>Result: <code>[\"Alice\", \"Carol\"]</code></p>"},{"location":"advanced/lexical-scoping/#syntax","title":"Syntax","text":"<pre><code>let $var1 = expr1, $var2 = expr2, ... in body\n</code></pre> <ul> <li>Variable names start with <code>$</code></li> <li>Multiple bindings separated by commas</li> <li>Bindings evaluated left-to-right (later can reference earlier)</li> <li>Body expression can use all bound variables</li> </ul>"},{"location":"advanced/lexical-scoping/#examples","title":"Examples","text":"<p>Multiple bindings:</p> <pre><code>let $total = sum(items[*].price),\n    $count = length(items)\nin { total: $total, average: `$total / $count` }\n</code></pre> <p>Chained bindings:</p> <pre><code>let $prices = items[*].price,\n    $avg = avg($prices),\n    $max = max($prices)\nin { average: $avg, max: $max, range: `$max - $avg` }\n</code></pre>"},{"location":"advanced/lexical-scoping/#root-reference","title":"Root Reference","text":"<p>The special variable <code>$</code> always refers to the root document:</p> <pre><code>// Given: {\"users\": [{\"name\": \"Alice\", \"role\": \"admin\"}], \"adminCount\": 1}\nString expr = \"users[?role == 'admin'] | length(@) == $.adminCount\";\n</code></pre> <p>This compares the filtered array length against the root's <code>adminCount</code> field.</p>"},{"location":"advanced/lexical-scoping/#root-reference-in-filters","title":"Root Reference in Filters","text":"<pre><code>{\n  \"threshold\": 100,\n  \"items\": [\n    {\"name\": \"A\", \"value\": 150},\n    {\"name\": \"B\", \"value\": 50},\n    {\"name\": \"C\", \"value\": 200}\n  ]\n}\n</code></pre> <pre><code>items[?value &gt; $.threshold].name\n</code></pre> <p>Result: <code>[\"A\", \"C\"]</code></p>"},{"location":"advanced/lexical-scoping/#combining-let-and-root","title":"Combining Let and Root","text":"<pre><code>{\n  \"config\": {\"minAge\": 21},\n  \"people\": [\n    {\"name\": \"Alice\", \"age\": 30},\n    {\"name\": \"Bob\", \"age\": 18},\n    {\"name\": \"Carol\", \"age\": 25}\n  ]\n}\n</code></pre> <pre><code>let $min = $.config.minAge\nin $.people[?age &gt;= $min].name\n</code></pre> <p>Result: <code>[\"Alice\", \"Carol\"]</code></p>"},{"location":"advanced/lexical-scoping/#scope-rules","title":"Scope Rules","text":"<p>Variables follow lexical scoping:</p> <ol> <li>Inner <code>let</code> expressions can shadow outer variables</li> <li>Variables are only visible in their <code>in</code> body</li> <li>Function bodies have their own scope</li> </ol> <p>Shadowing example:</p> <pre><code>let $x = `1`\nin let $x = `2`\n   in $x\n</code></pre> <p>Result: <code>2</code></p> <p>Scope isolation:</p> <pre><code>let $x = `1`\nin [$x, (let $x = `2` in $x), $x]\n</code></pre> <p>Result: <code>[1, 2, 1]</code></p>"},{"location":"advanced/lexical-scoping/#practical-examples","title":"Practical Examples","text":""},{"location":"advanced/lexical-scoping/#compare-to-group-statistics","title":"Compare to Group Statistics","text":"<pre><code>{\n  \"scores\": [85, 90, 78, 92, 88]\n}\n</code></pre> <p>Find scores above average:</p> <pre><code>let $avg = avg(scores)\nin scores[? @ &gt; $avg]\n</code></pre> <p>Result: <code>[90, 92, 88]</code></p>"},{"location":"advanced/lexical-scoping/#cross-reference-data","title":"Cross-Reference Data","text":"<pre><code>{\n  \"users\": [\n    {\"id\": 1, \"name\": \"Alice\"},\n    {\"id\": 2, \"name\": \"Bob\"}\n  ],\n  \"posts\": [\n    {\"authorId\": 1, \"title\": \"Hello\"},\n    {\"authorId\": 1, \"title\": \"World\"},\n    {\"authorId\": 2, \"title\": \"Test\"}\n  ]\n}\n</code></pre> <p>Count posts per user:</p> <pre><code>let $posts = $.posts\nin users[*].{\n  name: name,\n  postCount: length($posts[?authorId == $.id])\n}\n</code></pre>"},{"location":"advanced/lexical-scoping/#threshold-filtering","title":"Threshold Filtering","text":"<pre><code>{\n  \"settings\": {\"minPrice\": 10, \"maxPrice\": 100},\n  \"products\": [\n    {\"name\": \"A\", \"price\": 5},\n    {\"name\": \"B\", \"price\": 50},\n    {\"name\": \"C\", \"price\": 150}\n  ]\n}\n</code></pre> <pre><code>let $min = $.settings.minPrice,\n    $max = $.settings.maxPrice\nin $.products[?price &gt;= $min &amp;&amp; price &lt;= $max].name\n</code></pre> <p>Result: <code>[\"B\"]</code></p>"},{"location":"advanced/lexical-scoping/#java-usage","title":"Java Usage","text":"<pre><code>JmesPath jmespath = JmesPath.create();\n\n// Let expression\nExpression&lt;Object&gt; expr = jmespath.compile(\n    \"let $avg = avg(scores) in scores[? @ &gt; $avg]\"\n);\n\nMap&lt;String, Object&gt; data = Map.of(\n    \"scores\", List.of(85, 90, 78, 92, 88)\n);\n\nObject result = expr.evaluate(data);\n// [90, 92, 88]\n</code></pre> <pre><code>// Root reference\nExpression&lt;Object&gt; expr = jmespath.compile(\n    \"items[?value &gt; $.threshold].name\"\n);\n\nMap&lt;String, Object&gt; data = Map.of(\n    \"threshold\", 100,\n    \"items\", List.of(\n        Map.of(\"name\", \"A\", \"value\", 150),\n        Map.of(\"name\", \"B\", \"value\", 50)\n    )\n);\n\nObject result = expr.evaluate(data);\n// [\"A\"]\n</code></pre>"},{"location":"advanced/lexical-scoping/#performance-notes","title":"Performance Notes","text":"<ul> <li>Variable bindings are evaluated once when entering the <code>let</code> scope</li> <li>References to variables are simple lookups (no re-evaluation)</li> <li>The root reference <code>$</code> is always available at zero cost</li> </ul>"},{"location":"advanced/raw-strings/","title":"Raw Strings (JEP-12)","text":"<p>Raw string literals provide a simpler way to write string values without JSON escaping.</p>"},{"location":"advanced/raw-strings/#the-problem","title":"The Problem","text":"<p>In standard JMESPath, string literals in filters require JSON syntax:</p> <pre><code>// JSON literal - needs escaping\nJmesPath.search(\"items[?path == `\\\"C:\\\\\\\\Users\\\\\\\\file.txt\\\"`]\", data);\n</code></pre> <p>That's hard to read and easy to get wrong.</p>"},{"location":"advanced/raw-strings/#the-solution","title":"The Solution","text":"<p>Raw strings use single quotes and don't interpret escape sequences:</p> <pre><code>// Raw string - much cleaner\nJmesPath.search(\"items[?path == 'C:\\\\Users\\\\file.txt']\", data);\n</code></pre>"},{"location":"advanced/raw-strings/#syntax","title":"Syntax","text":"Syntax Result <code>'hello'</code> <code>hello</code> <code>'foo\\nbar'</code> <code>foo\\nbar</code> (literal backslash-n) <code>'it\\'s ok'</code> <code>it's ok</code> (escaped single quote) <code>'C:\\path\\to\\file'</code> <code>C:\\path\\to\\file</code> <p>The only escape sequence is <code>\\'</code> for a literal single quote.</p>"},{"location":"advanced/raw-strings/#comparison-with-json-literals","title":"Comparison with JSON Literals","text":"Raw String JSON Literal Value <code>'hello'</code> <code>`\"hello\"`</code> <code>hello</code> <code>'foo\\nbar'</code> <code>`\"foo\\\\nbar\"`</code> <code>foo\\nbar</code> <code>'tab\\there'</code> <code>`\"tab\\\\there\"`</code> <code>tab\\there</code> <p>JSON literals interpret escape sequences:</p> <pre><code>// Raw string: literal \\n characters\nJmesPath.search(\"'hello\\\\nworld'\", data);  // \"hello\\nworld\"\n\n// JSON literal: actual newline\nJmesPath.search(\"`\\\"hello\\\\nworld\\\"`\", data);  // \"hello\n                                                //  world\"\n</code></pre>"},{"location":"advanced/raw-strings/#use-cases","title":"Use Cases","text":""},{"location":"advanced/raw-strings/#file-paths","title":"File Paths","text":"<pre><code>// Windows paths\nJmesPath.search(\"files[?path == 'C:\\\\Users\\\\docs\\\\file.txt']\", data);\n\n// Unix paths (no escaping needed either way)\nJmesPath.search(\"files[?path == '/usr/local/bin']\", data);\n</code></pre>"},{"location":"advanced/raw-strings/#regular-expression-patterns","title":"Regular Expression Patterns","text":"<pre><code>// Regex with backslashes\nJmesPath.search(\"items[?matches(name, '\\\\d{3}-\\\\d{4}')]\", data);\n</code></pre>"},{"location":"advanced/raw-strings/#urls-and-uris","title":"URLs and URIs","text":"<pre><code>JmesPath.search(\"links[?url == 'https://example.com/path?foo=bar&amp;baz=qux']\", data);\n</code></pre>"},{"location":"advanced/raw-strings/#simple-string-matching","title":"Simple String Matching","text":"<pre><code>// Cleaner than JSON literals for basic strings\nJmesPath.search(\"users[?name == 'Alice']\", data);\nJmesPath.search(\"items[?status == 'pending']\", data);\n</code></pre>"},{"location":"advanced/raw-strings/#escaping-single-quotes","title":"Escaping Single Quotes","text":"<p>To include a literal single quote, use <code>\\'</code>:</p> <pre><code>JmesPath.search(\"messages[?text == 'it\\\\'s working']\", data);\n// Matches: {\"text\": \"it's working\"}\n</code></pre>"},{"location":"advanced/raw-strings/#when-to-use-what","title":"When to Use What","text":"Use Case Recommended Simple strings Raw string: <code>'hello'</code> Strings with backslashes Raw string: <code>'C:\\path'</code> Strings with single quotes JSON literal: <code>`\"it's\"`</code> Numbers, booleans, null JSON literal: <code>`42`</code>, <code>`true`</code> Complex JSON values JSON literal: <code>`{\"key\": \"value\"}`</code>"},{"location":"advanced/raw-strings/#examples","title":"Examples","text":"<pre><code>// Filter by status\nJmesPath.search(\"orders[?status == 'shipped']\", data);\n\n// Filter by path pattern\nJmesPath.search(\"files[?starts_with(path, '/var/log/')]\", data);\n\n// Combine with other conditions\nJmesPath.search(\"items[?type == 'book' &amp;&amp; price &lt; `20`]\", data);\n\n// In projections\nJmesPath.search(\"users[*].{name: name, role: 'user'}\", data);\n</code></pre>"},{"location":"guide/basics/","title":"Basic Queries","text":""},{"location":"guide/basics/#property-access","title":"Property Access","text":"<p>Access object properties with dot notation:</p> <pre><code>// {\"name\": \"Alice\", \"address\": {\"city\": \"Seattle\"}}\n\nJmesPath.search(\"name\", data);           // \"Alice\"\nJmesPath.search(\"address.city\", data);   // \"Seattle\"\nJmesPath.search(\"missing\", data);        // null\n</code></pre>"},{"location":"guide/basics/#quoted-identifiers","title":"Quoted Identifiers","text":"<p>For property names with special characters, use quotes:</p> <pre><code>// {\"foo-bar\": 1, \"with spaces\": 2}\n\nJmesPath.search(\"\\\"foo-bar\\\"\", data);      // 1\nJmesPath.search(\"\\\"with spaces\\\"\", data);  // 2\n</code></pre>"},{"location":"guide/basics/#array-access","title":"Array Access","text":""},{"location":"guide/basics/#index-access","title":"Index Access","text":"<pre><code>// {\"items\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}\n\nJmesPath.search(\"items[0]\", data);   // \"a\" (first)\nJmesPath.search(\"items[2]\", data);   // \"c\" (third)\nJmesPath.search(\"items[-1]\", data);  // \"e\" (last)\nJmesPath.search(\"items[-2]\", data);  // \"d\" (second to last)\n</code></pre>"},{"location":"guide/basics/#slicing","title":"Slicing","text":"<p>Extract a range of elements with <code>[start:stop:step]</code>:</p> <pre><code>// {\"items\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}\n\nJmesPath.search(\"items[0:5]\", data);    // [0, 1, 2, 3, 4]\nJmesPath.search(\"items[5:]\", data);     // [5, 6, 7, 8, 9]\nJmesPath.search(\"items[:3]\", data);     // [0, 1, 2]\nJmesPath.search(\"items[::2]\", data);    // [0, 2, 4, 6, 8] (every other)\nJmesPath.search(\"items[::-1]\", data);   // [9, 8, 7, ...] (reversed)\n</code></pre>"},{"location":"guide/basics/#wildcard-expressions","title":"Wildcard Expressions","text":""},{"location":"guide/basics/#list-wildcard","title":"List Wildcard <code>[*]</code>","text":"<p>Apply an expression to every element:</p> <pre><code>// {\"people\": [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]}\n\nJmesPath.search(\"people[*].name\", data);  // [\"Alice\", \"Bob\"]\n</code></pre>"},{"location":"guide/basics/#object-wildcard","title":"Object Wildcard <code>*</code>","text":"<p>Get all values from an object:</p> <pre><code>// {\"a\": 1, \"b\": 2, \"c\": 3}\n\nJmesPath.search(\"*\", data);  // [1, 2, 3]\n</code></pre>"},{"location":"guide/basics/#nested-wildcards","title":"Nested Wildcards","text":"<pre><code>// {\n//   \"departments\": {\n//     \"engineering\": {\"headcount\": 50},\n//     \"sales\": {\"headcount\": 30}\n//   }\n// }\n\nJmesPath.search(\"departments.*.headcount\", data);  // [50, 30]\n</code></pre>"},{"location":"guide/basics/#flatten-operator","title":"Flatten Operator <code>[]</code>","text":"<p>Flatten nested arrays by one level:</p> <pre><code>// {\"matrix\": [[1, 2], [3, 4], [5, 6]]}\n\nJmesPath.search(\"matrix[]\", data);  // [1, 2, 3, 4, 5, 6]\n</code></pre> <p>Commonly used to flatten projection results:</p> <pre><code>// {\n//   \"reservations\": [\n//     {\"instances\": [{\"id\": \"i-1\"}, {\"id\": \"i-2\"}]},\n//     {\"instances\": [{\"id\": \"i-3\"}]}\n//   ]\n// }\n\n// Without flatten - nested arrays\nJmesPath.search(\"reservations[*].instances[*].id\", data);\n// [[\"i-1\", \"i-2\"], [\"i-3\"]]\n\n// With flatten - single array\nJmesPath.search(\"reservations[].instances[].id\", data);\n// [\"i-1\", \"i-2\", \"i-3\"]\n</code></pre>"},{"location":"guide/basics/#multi-select","title":"Multi-Select","text":""},{"location":"guide/basics/#multi-select-list-expr-expr","title":"Multi-Select List <code>[expr, expr, ...]</code>","text":"<p>Create an array from multiple expressions:</p> <pre><code>// {\"name\": \"Alice\", \"age\": 30, \"city\": \"Seattle\"}\n\nJmesPath.search(\"[name, age]\", data);  // [\"Alice\", 30]\n</code></pre>"},{"location":"guide/basics/#multi-select-hash-key-expr","title":"Multi-Select Hash <code>{key: expr, ...}</code>","text":"<p>Create an object with renamed keys:</p> <pre><code>JmesPath.search(\"{fullName: name, years: age}\", data);\n// {\"fullName\": \"Alice\", \"years\": 30}\n</code></pre> <p>Combine with projections:</p> <pre><code>// {\"people\": [{\"firstName\": \"Alice\", \"lastName\": \"Smith\"}]}\n\nJmesPath.search(\"people[*].{name: firstName, surname: lastName}\", data);\n// [{\"name\": \"Alice\", \"surname\": \"Smith\"}]\n</code></pre>"},{"location":"guide/basics/#current-node","title":"Current Node <code>@</code>","text":"<p>Reference the current node being evaluated:</p> <pre><code>// {\"items\": [1, 2, 3]}\n\nJmesPath.search(\"items[*] | sort(@)\", data);  // [1, 2, 3]\n</code></pre> <p>Useful in filter expressions:</p> <pre><code>// {\"values\": [1, 5, 3, 8, 2]}\n\nJmesPath.search(\"values[?@ &gt; `3`]\", data);  // [5, 8]\n</code></pre>"},{"location":"guide/basics/#next-steps","title":"Next Steps","text":"<ul> <li>Filters - Filter expressions with conditions</li> <li>Projections - Advanced projection patterns</li> <li>Pipes - Chaining expressions</li> </ul>"},{"location":"guide/filters/","title":"Filters","text":"<p>Filter expressions let you select array elements based on conditions.</p>"},{"location":"guide/filters/#basic-syntax","title":"Basic Syntax","text":"<pre><code>array[?condition]\n</code></pre> <p>The <code>?</code> indicates a filter expression. Only elements where the condition is truthy are included.</p> <pre><code>// {\"people\": [\n//   {\"name\": \"Alice\", \"age\": 25},\n//   {\"name\": \"Bob\", \"age\": 35},\n//   {\"name\": \"Charlie\", \"age\": 30}\n// ]}\n\nJmesPath.search(\"people[?age &gt; `30`]\", data);\n// [{\"name\": \"Bob\", \"age\": 35}]\n\nJmesPath.search(\"people[?age &gt;= `30`]\", data);\n// [{\"name\": \"Bob\", \"age\": 35}, {\"name\": \"Charlie\", \"age\": 30}]\n</code></pre>"},{"location":"guide/filters/#comparison-operators","title":"Comparison Operators","text":"Operator Description <code>==</code> Equal <code>!=</code> Not equal <code>&lt;</code> Less than <code>&lt;=</code> Less than or equal <code>&gt;</code> Greater than <code>&gt;=</code> Greater than or equal <pre><code>JmesPath.search(\"people[?name == 'Alice']\", data);\nJmesPath.search(\"people[?age != `25`]\", data);\nJmesPath.search(\"people[?age &lt; `30`]\", data);\n</code></pre>"},{"location":"guide/filters/#logical-operators","title":"Logical Operators","text":""},{"location":"guide/filters/#and","title":"AND (<code>&amp;&amp;</code>)","text":"<p>Both conditions must be true:</p> <pre><code>JmesPath.search(\"people[?age &gt; `25` &amp;&amp; age &lt; `35`]\", data);\n// [{\"name\": \"Charlie\", \"age\": 30}]\n</code></pre>"},{"location":"guide/filters/#or","title":"OR (<code>||</code>)","text":"<p>Either condition can be true:</p> <pre><code>JmesPath.search(\"people[?age &lt; `26` || age &gt; `34`]\", data);\n// [{\"name\": \"Alice\", \"age\": 25}, {\"name\": \"Bob\", \"age\": 35}]\n</code></pre>"},{"location":"guide/filters/#not","title":"NOT (<code>!</code>)","text":"<p>Negate a condition:</p> <pre><code>JmesPath.search(\"people[?!(age &gt; `30`)]\", data);\n// [{\"name\": \"Alice\", \"age\": 25}, {\"name\": \"Charlie\", \"age\": 30}]\n</code></pre>"},{"location":"guide/filters/#string-comparisons","title":"String Comparisons","text":"<pre><code>// {\"items\": [\n//   {\"name\": \"apple\"},\n//   {\"name\": \"banana\"},\n//   {\"name\": \"apricot\"}\n// ]}\n\n// Exact match (use raw strings with single quotes)\nJmesPath.search(\"items[?name == 'apple']\", data);\n\n// Use functions for partial matches\nJmesPath.search(\"items[?starts_with(name, 'ap')]\", data);\n// [{\"name\": \"apple\"}, {\"name\": \"apricot\"}]\n\nJmesPath.search(\"items[?contains(name, 'an')]\", data);\n// [{\"name\": \"banana\"}]\n</code></pre>"},{"location":"guide/filters/#filtering-nested-data","title":"Filtering Nested Data","text":"<pre><code>// {\n//   \"orders\": [\n//     {\"id\": 1, \"items\": [{\"product\": \"A\", \"qty\": 2}]},\n//     {\"id\": 2, \"items\": [{\"product\": \"B\", \"qty\": 5}]}\n//   ]\n// }\n\n// Orders with any item quantity &gt; 3\nJmesPath.search(\"orders[?items[?qty &gt; `3`]]\", data);\n// [{\"id\": 2, ...}]\n</code></pre>"},{"location":"guide/filters/#filtering-with-functions","title":"Filtering with Functions","text":"<pre><code>// {\"files\": [\n//   {\"name\": \"doc.pdf\", \"size\": 1024},\n//   {\"name\": \"image.png\", \"size\": 2048},\n//   {\"name\": \"readme.txt\", \"size\": 512}\n// ]}\n\n// Files ending with .pdf\nJmesPath.search(\"files[?ends_with(name, '.pdf')]\", data);\n\n// Files larger than average\nJmesPath.search(\"files[?size &gt; avg(files[*].size)]\", data);\n</code></pre>"},{"location":"guide/filters/#chaining-filters-with-projections","title":"Chaining Filters with Projections","text":"<p>After filtering, project specific fields:</p> <pre><code>// Get just the names of people over 30\nJmesPath.search(\"people[?age &gt; `30`].name\", data);\n// [\"Bob\"]\n\n// Get specific fields\nJmesPath.search(\"people[?age &gt; `25`].{n: name, a: age}\", data);\n// [{\"n\": \"Bob\", \"a\": 35}, {\"n\": \"Charlie\", \"a\": 30}]\n</code></pre>"},{"location":"guide/filters/#truthiness","title":"Truthiness","text":"<p>In filter expressions, these values are falsy:</p> <ul> <li><code>null</code></li> <li><code>false</code></li> <li>Empty string <code>\"\"</code></li> <li>Empty array <code>[]</code></li> <li>Empty object <code>{}</code></li> </ul> <p>Everything else is truthy.</p> <pre><code>// {\"items\": [\n//   {\"name\": \"A\", \"active\": true},\n//   {\"name\": \"B\", \"active\": false},\n//   {\"name\": \"C\", \"active\": null}\n// ]}\n\nJmesPath.search(\"items[?active]\", data);\n// [{\"name\": \"A\", \"active\": true}]\n\nJmesPath.search(\"items[?!active]\", data);\n// [{\"name\": \"B\", ...}, {\"name\": \"C\", ...}]\n</code></pre>"},{"location":"guide/filters/#literal-values","title":"Literal Values","text":"<p>Use backticks for JSON literals in comparisons:</p> <pre><code>// Numbers\nJmesPath.search(\"items[?count &gt; `10`]\", data);\n\n// Booleans\nJmesPath.search(\"items[?active == `true`]\", data);\n\n// Null\nJmesPath.search(\"items[?value == `null`]\", data);\n\n// Strings (alternative to raw strings)\nJmesPath.search(\"items[?name == `\\\"Alice\\\"`]\", data);\n</code></pre> <p>Raw Strings</p> <p>For string comparisons, raw strings with single quotes are cleaner: <pre><code>JmesPath.search(\"items[?name == 'Alice']\", data);\n</code></pre></p>"},{"location":"guide/functions/","title":"Functions","text":"<p>jmespath-jvm includes all 26 standard JMESPath functions.</p>"},{"location":"guide/functions/#numeric-functions","title":"Numeric Functions","text":""},{"location":"guide/functions/#abs","title":"abs","text":"<p>Absolute value.</p> <pre><code>JmesPath.search(\"abs(`-5`)\", data);  // 5\n</code></pre>"},{"location":"guide/functions/#avg","title":"avg","text":"<p>Average of an array of numbers.</p> <pre><code>JmesPath.search(\"avg(scores)\", data);  // e.g., 85.5\n</code></pre>"},{"location":"guide/functions/#ceil","title":"ceil","text":"<p>Round up to nearest integer.</p> <pre><code>JmesPath.search(\"ceil(`4.2`)\", data);  // 5\n</code></pre>"},{"location":"guide/functions/#floor","title":"floor","text":"<p>Round down to nearest integer.</p> <pre><code>JmesPath.search(\"floor(`4.8`)\", data);  // 4\n</code></pre>"},{"location":"guide/functions/#sum","title":"sum","text":"<p>Sum of an array of numbers.</p> <pre><code>JmesPath.search(\"sum(prices)\", data);  // e.g., 150\n</code></pre>"},{"location":"guide/functions/#string-functions","title":"String Functions","text":""},{"location":"guide/functions/#contains","title":"contains","text":"<p>Check if a string contains a substring (or array contains an element).</p> <pre><code>JmesPath.search(\"contains('hello world', 'world')\", data);  // true\nJmesPath.search(\"contains(tags, 'urgent')\", data);  // true/false\n</code></pre>"},{"location":"guide/functions/#ends_with","title":"ends_with","text":"<p>Check if a string ends with a suffix.</p> <pre><code>JmesPath.search(\"ends_with(filename, '.pdf')\", data);  // true/false\n</code></pre>"},{"location":"guide/functions/#starts_with","title":"starts_with","text":"<p>Check if a string starts with a prefix.</p> <pre><code>JmesPath.search(\"starts_with(name, 'Dr.')\", data);  // true/false\n</code></pre>"},{"location":"guide/functions/#join","title":"join","text":"<p>Join an array of strings with a separator.</p> <pre><code>JmesPath.search(\"join(', ', names)\", data);  // \"Alice, Bob, Charlie\"\n</code></pre>"},{"location":"guide/functions/#length","title":"length","text":"<p>Length of a string, array, or object.</p> <pre><code>JmesPath.search(\"length(name)\", data);    // string length\nJmesPath.search(\"length(items)\", data);   // array length\nJmesPath.search(\"length(@)\", data);       // object key count\n</code></pre>"},{"location":"guide/functions/#array-functions","title":"Array Functions","text":""},{"location":"guide/functions/#reverse","title":"reverse","text":"<p>Reverse an array or string.</p> <pre><code>JmesPath.search(\"reverse(items)\", data);   // [c, b, a]\nJmesPath.search(\"reverse('hello')\", data); // \"olleh\"\n</code></pre>"},{"location":"guide/functions/#sort","title":"sort","text":"<p>Sort an array of strings or numbers.</p> <pre><code>JmesPath.search(\"sort(names)\", data);    // alphabetical\nJmesPath.search(\"sort(scores)\", data);   // numerical\n</code></pre>"},{"location":"guide/functions/#sort_by","title":"sort_by","text":"<p>Sort an array of objects by a key expression.</p> <pre><code>JmesPath.search(\"sort_by(people, &amp;age)\", data);\nJmesPath.search(\"sort_by(people, &amp;name)\", data);\n</code></pre> <p>Expression References</p> <p>The <code>&amp;</code> prefix creates an expression reference, evaluated for each element.</p>"},{"location":"guide/functions/#max-min","title":"max / min","text":"<p>Get maximum or minimum value.</p> <pre><code>JmesPath.search(\"max(scores)\", data);  // highest score\nJmesPath.search(\"min(ages)\", data);    // lowest age\n</code></pre>"},{"location":"guide/functions/#max_by-min_by","title":"max_by / min_by","text":"<p>Get element with maximum or minimum value by expression.</p> <pre><code>JmesPath.search(\"max_by(people, &amp;age)\", data);        // oldest person object\nJmesPath.search(\"max_by(people, &amp;age).name\", data);   // oldest person's name\nJmesPath.search(\"min_by(products, &amp;price)\", data);    // cheapest product\n</code></pre>"},{"location":"guide/functions/#map","title":"map","text":"<p>Apply an expression to each element.</p> <pre><code>JmesPath.search(\"map(&amp;age, people)\", data);  // [25, 30, 35]\n</code></pre>"},{"location":"guide/functions/#object-functions","title":"Object Functions","text":""},{"location":"guide/functions/#keys","title":"keys","text":"<p>Get object keys as an array.</p> <pre><code>JmesPath.search(\"keys(@)\", data);  // [\"name\", \"age\", \"city\"]\n</code></pre>"},{"location":"guide/functions/#values","title":"values","text":"<p>Get object values as an array.</p> <pre><code>JmesPath.search(\"values(@)\", data);  // [\"Alice\", 30, \"Seattle\"]\n</code></pre>"},{"location":"guide/functions/#merge","title":"merge","text":"<p>Merge multiple objects.</p> <pre><code>JmesPath.search(\"merge(defaults, overrides)\", data);\nJmesPath.search(\"merge(`{\\\"a\\\": 1}`, `{\\\"b\\\": 2}`)\", data);  // {\"a\": 1, \"b\": 2}\n</code></pre>"},{"location":"guide/functions/#conversion-functions","title":"Conversion Functions","text":""},{"location":"guide/functions/#to_array","title":"to_array","text":"<p>Convert a value to an array.</p> <pre><code>JmesPath.search(\"to_array('hello')\", data);  // [\"hello\"]\nJmesPath.search(\"to_array(items)\", data);    // items (if already array)\n</code></pre>"},{"location":"guide/functions/#to_number","title":"to_number","text":"<p>Convert to a number.</p> <pre><code>JmesPath.search(\"to_number('42')\", data);     // 42\nJmesPath.search(\"to_number('invalid')\", data); // null\n</code></pre>"},{"location":"guide/functions/#to_string","title":"to_string","text":"<p>Convert to a string.</p> <pre><code>JmesPath.search(\"to_string(`42`)\", data);     // \"42\"\nJmesPath.search(\"to_string(`true`)\", data);   // \"true\"\n</code></pre>"},{"location":"guide/functions/#type","title":"type","text":"<p>Get the type name.</p> <pre><code>JmesPath.search(\"type(name)\", data);    // \"string\"\nJmesPath.search(\"type(age)\", data);     // \"number\"\nJmesPath.search(\"type(items)\", data);   // \"array\"\nJmesPath.search(\"type(@)\", data);       // \"object\"\nJmesPath.search(\"type(`null`)\", data);  // \"null\"\nJmesPath.search(\"type(`true`)\", data);  // \"boolean\"\n</code></pre>"},{"location":"guide/functions/#utility-functions","title":"Utility Functions","text":""},{"location":"guide/functions/#not_null","title":"not_null","text":"<p>Return the first non-null argument.</p> <pre><code>JmesPath.search(\"not_null(preferred_name, nickname, name)\", data);\n</code></pre>"},{"location":"guide/functions/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/functions/#get-top-n","title":"Get Top N","text":"<pre><code>JmesPath.search(\"sort_by(items, &amp;score) | reverse(@) | [:5]\", data);\n</code></pre>"},{"location":"guide/functions/#count-matches","title":"Count Matches","text":"<pre><code>JmesPath.search(\"length(items[?active])\", data);\n</code></pre>"},{"location":"guide/functions/#check-if-any-match","title":"Check If Any Match","text":"<pre><code>JmesPath.search(\"length(items[?status == 'error']) &gt; `0`\", data);\n</code></pre>"},{"location":"guide/functions/#get-unique-property-values","title":"Get Unique Property Values","text":"<pre><code>// Using sort to deduplicate (works for sorted data)\nJmesPath.search(\"sort(items[*].category)\", data);\n</code></pre>"},{"location":"guide/functions/#aggregate-calculations","title":"Aggregate Calculations","text":"<pre><code>// Total value\nJmesPath.search(\"sum(items[*].price)\", data);\n\n// Average rating for active items\nJmesPath.search(\"avg(items[?active].rating)\", data);\n</code></pre>"},{"location":"guide/pipes/","title":"Pipes","text":"<p>The pipe operator <code>|</code> chains expressions together, passing the output of one as input to the next.</p>"},{"location":"guide/pipes/#basic-syntax","title":"Basic Syntax","text":"<pre><code>expression | expression | expression\n</code></pre> <p>Each expression receives the result of the previous one:</p> <pre><code>// {\"items\": [3, 1, 4, 1, 5, 9, 2, 6]}\n\nJmesPath.search(\"items | sort(@) | reverse(@)\", data);\n// [9, 6, 5, 4, 3, 2, 1, 1]\n</code></pre>"},{"location":"guide/pipes/#stopping-projections","title":"Stopping Projections","text":"<p>Pipes stop active projections. This is their most important use:</p> <pre><code>// {\"items\": [{\"a\": 1}, {\"a\": 2}, {\"a\": 3}]}\n\n// Without pipe - still in projection context\nJmesPath.search(\"items[*].a\", data);\n// [1, 2, 3]\n\n// With pipe - operate on the projected array\nJmesPath.search(\"items[*].a | [0]\", data);\n// 1 (first element of the array)\n</code></pre> <p>Compare:</p> <pre><code>// items[*].a[0] - tries to get [0] from each 'a' value (numbers have no index)\nJmesPath.search(\"items[*].a[0]\", data);  // [null, null, null]\n\n// items[*].a | [0] - get [0] from the array of 'a' values\nJmesPath.search(\"items[*].a | [0]\", data);  // 1\n</code></pre>"},{"location":"guide/pipes/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/pipes/#sort-and-slice","title":"Sort and Slice","text":"<pre><code>// Get top 3 highest scores\nJmesPath.search(\"scores | sort(@) | reverse(@) | [:3]\", data);\n\n// Get 3 oldest people's names\nJmesPath.search(\"sort_by(people, &amp;age) | reverse(@) | [:3] | [*].name\", data);\n</code></pre>"},{"location":"guide/pipes/#filter-then-aggregate","title":"Filter Then Aggregate","text":"<pre><code>// Count active users\nJmesPath.search(\"users[?active] | length(@)\", data);\n\n// Average score of passing grades\nJmesPath.search(\"grades[?score &gt;= `60`].score | avg(@)\", data);\n</code></pre>"},{"location":"guide/pipes/#transform-then-filter","title":"Transform Then Filter","text":"<pre><code>// Get names, then filter by length\nJmesPath.search(\"people[*].name | [?length(@) &gt; `5`]\", data);\n</code></pre>"},{"location":"guide/pipes/#multiple-transformations","title":"Multiple Transformations","text":"<pre><code>// Complex data pipeline\nJmesPath.search(\n    \"orders[?status == 'completed'].items[] | \" +\n    \"sort_by(@, &amp;price) | \" +\n    \"reverse(@) | \" +\n    \"[:10] | \" +\n    \"[*].{name: productName, cost: price}\",\n    data\n);\n</code></pre>"},{"location":"guide/pipes/#current-node-in-pipes","title":"Current Node in Pipes","text":"<p>The <code>@</code> symbol represents the current value at each stage:</p> <pre><code>// {\"numbers\": [5, 2, 8, 1, 9]}\n\nJmesPath.search(\"numbers | sort(@)\", data);    // [1, 2, 5, 8, 9]\nJmesPath.search(\"numbers | reverse(@)\", data); // [9, 1, 8, 2, 5]\nJmesPath.search(\"numbers | max(@)\", data);     // 9\nJmesPath.search(\"numbers | length(@)\", data);  // 5\n</code></pre>"},{"location":"guide/pipes/#right-to-left-evaluation","title":"Right-to-Left Evaluation","text":"<p>Pipes evaluate left-to-right:</p> <pre><code>// {\"data\": {\"items\": [1, 2, 3]}}\n\nJmesPath.search(\"data.items | sort(@) | [0]\", data);\n// Evaluates as: data.items -&gt; [1,2,3] -&gt; sort -&gt; [1,2,3] -&gt; [0] -&gt; 1\n</code></pre>"},{"location":"guide/pipes/#combining-with-other-operators","title":"Combining with Other Operators","text":""},{"location":"guide/pipes/#pipes-in-multi-select","title":"Pipes in Multi-Select","text":"<pre><code>JmesPath.search(\n    \"{sorted: items | sort(@), count: items | length(@)}\",\n    data\n);\n</code></pre>"},{"location":"guide/pipes/#pipes-after-filters","title":"Pipes After Filters","text":"<pre><code>JmesPath.search(\n    \"items[?price &gt; `100`] | sort_by(@, &amp;price) | [0].name\",\n    data\n);\n</code></pre>"},{"location":"guide/pipes/#when-to-use-pipes","title":"When to Use Pipes","text":"Use Case Example Stop a projection <code>items[*].x | [0]</code> Chain functions <code>data | sort(@) | reverse(@)</code> Apply functions to filtered results <code>items[?active] | length(@)</code> Complex transformations Multiple stages of processing"},{"location":"guide/pipes/#pipes-vs-dot","title":"Pipes vs Dot","text":"<ul> <li>Dot (<code>.</code>) continues into substructure, maintains projection</li> <li>Pipe (<code>|</code>) passes entire result to next expression, stops projection</li> </ul> <pre><code>// These are different:\nJmesPath.search(\"items[*].name[0]\", data);   // first char of each name\nJmesPath.search(\"items[*].name | [0]\", data); // first name in array\n</code></pre>"},{"location":"guide/projections/","title":"Projections","text":"<p>Projections apply an expression to every element in an array, collecting results into a new array.</p>"},{"location":"guide/projections/#list-projections","title":"List Projections <code>[*]</code>","text":"<p>The wildcard <code>[*]</code> creates a projection:</p> <pre><code>// {\"people\": [\n//   {\"name\": \"Alice\", \"age\": 25},\n//   {\"name\": \"Bob\", \"age\": 30}\n// ]}\n\nJmesPath.search(\"people[*].name\", data);\n// [\"Alice\", \"Bob\"]\n\nJmesPath.search(\"people[*].age\", data);\n// [25, 30]\n</code></pre>"},{"location":"guide/projections/#object-projections","title":"Object Projections <code>*</code>","text":"<p>Project over object values:</p> <pre><code>// {\"scores\": {\"math\": 90, \"science\": 85, \"english\": 92}}\n\nJmesPath.search(\"scores.*\", data);\n// [90, 85, 92]\n</code></pre>"},{"location":"guide/projections/#slice-projections-startstop","title":"Slice Projections <code>[start:stop]</code>","text":"<p>Slices also create projections:</p> <pre><code>// {\"items\": [\n//   {\"id\": 1}, {\"id\": 2}, {\"id\": 3}, {\"id\": 4}, {\"id\": 5}\n// ]}\n\nJmesPath.search(\"items[:3].id\", data);\n// [1, 2, 3]\n\nJmesPath.search(\"items[2:].id\", data);\n// [3, 4, 5]\n</code></pre>"},{"location":"guide/projections/#filter-projections-expr","title":"Filter Projections <code>[?expr]</code>","text":"<p>Filters are projections too:</p> <pre><code>JmesPath.search(\"people[?age &gt; `25`].name\", data);\n// [\"Bob\"]\n</code></pre>"},{"location":"guide/projections/#flatten-projections","title":"Flatten Projections <code>[]</code>","text":"<p>The flatten operator creates a projection that also flattens:</p> <pre><code>// {\"groups\": [\n//   {\"members\": [\"Alice\", \"Bob\"]},\n//   {\"members\": [\"Charlie\"]}\n// ]}\n\n// With [*] - nested arrays\nJmesPath.search(\"groups[*].members\", data);\n// [[\"Alice\", \"Bob\"], [\"Charlie\"]]\n\n// With [] - flattened\nJmesPath.search(\"groups[].members\", data);\n// [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre>"},{"location":"guide/projections/#projection-chaining","title":"Projection Chaining","text":"<p>Projections can be chained:</p> <pre><code>// {\"data\": [\n//   {\"items\": [{\"val\": 1}, {\"val\": 2}]},\n//   {\"items\": [{\"val\": 3}]}\n// ]}\n\nJmesPath.search(\"data[*].items[*].val\", data);\n// [[1, 2], [3]]\n\nJmesPath.search(\"data[].items[].val\", data);\n// [1, 2, 3]\n</code></pre>"},{"location":"guide/projections/#stopping-projections","title":"Stopping Projections","text":"<p>Some expressions stop projections:</p> Expression Stops Projection? <code>[n]</code> (index) Yes <code>[*]</code> (wildcard) No <code>[]</code> (flatten) No <code>[?expr]</code> (filter) No <code>[start:stop]</code> (slice) No <code>.identifier</code> No <code>| expr</code> (pipe) Yes <pre><code>// {\"items\": [[1, 2], [3, 4], [5, 6]]}\n\n// [0] stops the projection\nJmesPath.search(\"items[*][0]\", data);\n// [1, 3, 5]\n\n// Pipe stops and restarts\nJmesPath.search(\"items[*] | [0]\", data);\n// [1, 2]\n</code></pre>"},{"location":"guide/projections/#null-handling","title":"Null Handling","text":"<p>Projections skip null results:</p> <pre><code>// {\"people\": [\n//   {\"name\": \"Alice\", \"nickname\": \"Ali\"},\n//   {\"name\": \"Bob\"},\n//   {\"name\": \"Charlie\", \"nickname\": \"Chuck\"}\n// ]}\n\nJmesPath.search(\"people[*].nickname\", data);\n// [\"Ali\", \"Chuck\"]  -- Bob's null is skipped\n</code></pre>"},{"location":"guide/projections/#multi-select-in-projections","title":"Multi-Select in Projections","text":"<p>Reshape data during projection:</p> <pre><code>// {\"users\": [\n//   {\"firstName\": \"Alice\", \"lastName\": \"Smith\", \"age\": 30},\n//   {\"firstName\": \"Bob\", \"lastName\": \"Jones\", \"age\": 25}\n// ]}\n\nJmesPath.search(\"users[*].{name: firstName, years: age}\", data);\n// [{\"name\": \"Alice\", \"years\": 30}, {\"name\": \"Bob\", \"years\": 25}]\n\nJmesPath.search(\"users[*].[firstName, lastName]\", data);\n// [[\"Alice\", \"Smith\"], [\"Bob\", \"Jones\"]]\n</code></pre>"},{"location":"guide/projections/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/projections/#get-all-ids","title":"Get All IDs","text":"<pre><code>JmesPath.search(\"items[*].id\", data);\n</code></pre>"},{"location":"guide/projections/#flatten-nested-lists","title":"Flatten Nested Lists","text":"<pre><code>JmesPath.search(\"orders[].lineItems[].productId\", data);\n</code></pre>"},{"location":"guide/projections/#filter-then-project","title":"Filter Then Project","text":"<pre><code>JmesPath.search(\"users[?active].email\", data);\n</code></pre>"},{"location":"guide/projections/#project-then-sort","title":"Project Then Sort","text":"<pre><code>JmesPath.search(\"items[*].name | sort(@)\", data);\n</code></pre>"}]}